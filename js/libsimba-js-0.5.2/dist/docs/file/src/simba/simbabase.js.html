<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  <base data-ice="baseUrl" href="../../../">
  <title data-ice="title">src/simba/simbabase.js | libsimba-js</title>
  <link type="text/css" rel="stylesheet" href="css/style.css">
  <link type="text/css" rel="stylesheet" href="css/prettify-tomorrow.css">
  <script src="script/prettify/prettify.js"></script>
  <script src="script/manual.js"></script>
<meta name="description" content="Simbachain Blockchain abstraction and interaction library"><meta property="twitter:card" content="summary"><meta property="twitter:title" content="libsimba-js"><meta property="twitter:description" content="Simbachain Blockchain abstraction and interaction library"></head>
<body class="layout-container" data-ice="rootContainer">

<header>
  <a href="./">Home</a>
  
  <a href="identifiers.html">Reference</a>
  <a href="source.html">Source</a>
  <a href="test.html" data-ice="testLink">Test</a>
  <div class="search-box">
  <span>
    <img src="./image/search.png">
    <span class="search-input-edge"></span><input class="search-input"><span class="search-input-edge"></span>
  </span>
    <ul class="search-result"></ul>
  </div>
<a style="position:relative; top:3px;" href="https://github.com/simbachain/libsimba-js"><img width="20px" src="./image/github.png"></a></header>

<nav class="navigation" data-ice="nav"><div>
  <ul>
    
  <li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/exceptions.js~BadMetadataException.html">BadMetadataException</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/exceptions.js~BaseException.html">BaseException</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/exceptions.js~GenerateTransactionException.html">GenerateTransactionException</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/exceptions.js~GetRequestException.html">GetRequestException</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/exceptions.js~GetTransactionsException.html">GetTransactionsException</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/exceptions.js~MethodCallValidationMetadataException.html">MethodCallValidationMetadataException</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/exceptions.js~MissingMetadataException.html">MissingMetadataException</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/exceptions.js~NotImplementedException.html">NotImplementedException</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/exceptions.js~NotInBrowserException.html">NotInBrowserException</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/exceptions.js~RetriesExceededException.html">RetriesExceededException</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/exceptions.js~SigningException.html">SigningException</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/exceptions.js~SubmitTransactionException.html">SubmitTransactionException</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/exceptions.js~TransactionStatusCheckException.html">TransactionStatusCheckException</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/exceptions.js~UserRejectedSigningException.html">UserRejectedSigningException</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/exceptions.js~WalletLockedException.html">WalletLockedException</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/exceptions.js~WalletNotFoundException.html">WalletNotFoundException</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-function">F</span><span data-ice="name"><span><a href="function/index.html#static-function-getSimbaInstance">getSimbaInstance</a></span></span></li>
<li data-ice="doc"><a data-ice="dirPath" class="nav-dir-path" href="identifiers.html#simba">simba</a><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/simba/pagedresponse.js~PagedResponse.html">PagedResponse</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/simba/simba.js~Simbachain.html">Simbachain</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/simba/simbabase.js~SimbaBase.html">SimbaBase</a></span></span></li>
<li data-ice="doc"><a data-ice="dirPath" class="nav-dir-path" href="identifiers.html#wallet">wallet</a><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/wallet/localwallet.js~LocalWallet.html">LocalWallet</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/wallet/pkwallet.js~PKWallet.html">PKWallet</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/wallet/wallet.js~Wallet.html">Wallet</a></span></span></li>
</ul>
</div>
</nav>

<div class="content" data-ice="content"><h1 data-ice="title">src/simba/simbabase.js</h1>
<pre class="source-code line-number raw-source-code"><code class="prettyprint linenums" data-ice="content">import {pollWrapper} from &quot;poll-js&quot;;
import {
    MissingMetadataException,
    NotImplementedException,
    BadMetadataException,
    MethodCallValidationMetadataException,
    GetTransactionsException
} from &apos;../exceptions&apos;;
import PagedResponse from &quot;./pagedresponse&quot;;

/**
 * @interface
 * Base class for libsimba API Interaction implementations
 */
export default class SimbaBase {
    /**
     * Base class for libsimba API Interaction implementations
     * @param {string} endpoint - The endpoint of the API
     * @param {Wallet} [wallet] - an optional {@link Wallet} instance
     */
    constructor(endpoint, wallet) {
        if (!endpoint.endsWith(&apos;/&apos;)) {
            this.endpoint = `${endpoint}/`;
        } else {
            this.endpoint = endpoint;
        }
        this.wallet = wallet;

        this.metadata = {};

        if (this.constructor === SimbaBase) {
            // Error Type 1. Abstract class can not be constructed.
            throw new TypeError(&apos;Can not construct abstract class.&apos;);
        }

        if (this.initialize === SimbaBase.prototype.initialize) {
            throw new NotImplementedException(&apos;Please implement abstract method callMethod.&apos;);
        }

        if (this.callMethod === SimbaBase.prototype.callMethod) {
            throw new NotImplementedException(&apos;Please implement abstract method callMethod.&apos;);
        }

        if (this.getTransactionStatus === SimbaBase.prototype.getTransactionStatus) {
            throw new NotImplementedException(&apos;Please implement abstract method getTransactionStatus.&apos;);
        }

        if (this.checkTransactionStatusFromObject === SimbaBase.prototype.checkTransactionStatusFromObject) {
            throw new NotImplementedException(&apos;Please implement abstract method checkTransactionStatusFromObject.&apos;);
        }

        if (this.checkTransactionDone === SimbaBase.prototype.checkTransactionDone) {
            throw new NotImplementedException(&apos;Please implement abstract method checkTransactionDone.&apos;);
        }

        if (this.checkTransactionStatus === SimbaBase.prototype.checkTransactionStatus) {
            throw new NotImplementedException(&apos;Please implement abstract method checkTransactionStatus.&apos;);
        }

        if (this.getBalance === SimbaBase.prototype.getBalance) {
            throw new NotImplementedException(&apos;Please implement abstract method getBalance.&apos;);
        }

        if (this.addFunds === SimbaBase.prototype.addFunds) {
            throw new NotImplementedException(&apos;Please implement abstract method addFunds.&apos;);
        }

        if (this.getMethodTransactions === SimbaBase.prototype.getMethodTransactions) {
            throw new NotImplementedException(&apos;Please implement abstract method getMethodTransactions.&apos;);
        }

        if (this.getTransaction === SimbaBase.prototype.getTransaction) {
            throw new NotImplementedException(&apos;Please implement abstract method getTransaction.&apos;);
        }

        if (this.getTransactions === SimbaBase.prototype.getTransactions) {
            throw new NotImplementedException(&apos;Please implement abstract method getTransactions.&apos;);
        }

        if (this.getBundleMetadataForTransaction === SimbaBase.prototype.getBundleMetadataForTransaction) {
            throw new NotImplementedException(&apos;Please implement abstract method getBundleMetadataForTransaction.&apos;);
        }

        if (this.getBundleForTransaction === SimbaBase.prototype.getBundleForTransaction) {
            throw new NotImplementedException(&apos;Please implement abstract method getBundleForTransaction.&apos;);
        }

        if (this.getFileFromBundleForTransaction === SimbaBase.prototype.getFileFromBundleForTransaction) {
            throw new NotImplementedException(&apos;Please implement abstract method getFileFromBundleForTransaction.&apos;);
        }

        if (this.getFileFromBundleByNameForTransaction === SimbaBase.prototype.getFileFromBundleByNameForTransaction) {
            throw new NotImplementedException(&apos;Please implement abstract method getFileFromBundleByNameForTransaction.&apos;);
        }

        if (this.sendTransactionRequest === SimbaBase.prototype.sendTransactionRequest) {
            throw new NotImplementedException(&apos;Please implement abstract method sendTransactionRequest.&apos;);
        }
    }

    /**
     * @abstract
     * (Abstract) Perform any asynchronous actions needed to initialise this class
     */
    initialize() {
        throw new NotImplementedException(&apos;SimbaBase.initialize Not Implemented&apos;);
    }

    /**
     * @abstract
     * (Abstract) Call a method on the API
     * @param {string} method - the method to call
     * @param {Object} parameters - the parameters for the method
     * @return {Promise} - a promise resolving with the transaction details
     */
    callMethod(method, parameters) {
        throw new NotImplementedException(&apos;SimbaBase.callMethod Not Implemented&apos;);
    }

    /**
     * @abstract
     * (Abstract) Gets a paged list of transactions for the method
     * @param {string} method - The method
     * @param {Object} parameters - The query parameters
     */
    getMethodTransactions(method, parameters) {
        throw new NotImplementedException(&apos;SimbaBase.callMethod Not Implemented&apos;);
    }

    /**
     * @abstract
     * (Abstract) Gets a specific transaction
     * @param {string} transactionIdOrHash - Either a transaction ID or a transaction hash
     * @returns {Promise&lt;Object&gt;} - The transaction
     */
    getTransaction(transactionIdOrHash) {
        throw new NotImplementedException(&apos;SimbaBase.getTransaction Not Implemented&apos;);
    }

    /**
     * @abstract
     * (Abstract) Gets a the bundle metadata for a transaction
     * @param {string} transactionIdOrHash - Either a transaction ID or a transaction hash
     * @returns {Promise&lt;Object&gt;} - The bundle metadata
     */
    getBundleMetadataForTransaction(transactionIdOrHash) {
        throw new NotImplementedException(&apos;SimbaBase.getTransaction Not Implemented&apos;);
    }

    /**
     * @abstract
     * (Abstract) Gets the bundle for a transaction
     * @param {string} transactionIdOrHash - Either a transaction ID or a transaction hash
     * @param {boolean} stream - If true, returns a {@link ReadableStream}, otherwise returns a {@link Blob}
     * @returns {Promise&lt;ReadableStream|Blob&gt;} - The bundle
     */
    getBundleForTransaction(transactionIdOrHash, stream) {
        throw new NotImplementedException(&apos;SimbaBase.getTransaction Not Implemented&apos;);
    }

    /**
     * @abstract
     * (Abstract) Gets a file from the bundle for a transaction
     * @param {string} transactionIdOrHash - Either a transaction ID or a transaction hash
     * @param {number} fileIdx - The index of the file in the bundle metadata
     * @param {boolean} stream - If true, returns a {@link ReadableStream}, otherwise returns a {@link Blob}
     * @returns {Promise&lt;ReadableStream|Blob&gt;} - The file
     */
    getFileFromBundleForTransaction(transactionIdOrHash, fileIdx, stream) {
        throw new NotImplementedException(&apos;SimbaBase.getTransaction Not Implemented&apos;);
    }

    /**
     * @abstract
     * (Abstract) Gets a file from the bundle for a transaction
     * @param {string} transactionIdOrHash - Either a transaction ID or a transaction hash
     * @param {string} fileName - The name of the file in the bundle metadata
     * @param {boolean} stream - If true, returns a {@link ReadableStream}, otherwise returns a {@link Blob}
     * @returns {Promise&lt;ReadableStream|Blob&gt;} - The file
     */
    getFileFromBundleByNameForTransaction(transactionIdOrHash, fileName, stream) {
        throw new NotImplementedException(&apos;SimbaBase.getTransaction Not Implemented&apos;);
    }

    /**
     * @abstract
     * (Abstract) Gets a paged list of transactions
     * @param {Object} parameters - The query parameters
     * @returns {Promise&lt;PagedResponse&gt;} - A response wrapped in a {@link PagedResponse} helper
     */
    getTransactions(parameters) {
        throw new NotImplementedException(&apos;SimbaBase.callMethod Not Implemented&apos;);
    }

    /**
     * @abstract
     * Internal function for sending transaction GET requests
     * @param {URL} url - The URL
     * @returns {Promise&lt;PagedResponse&gt;} - A response wrapped in a {@link PagedResponse} helper
     */
    async sendTransactionRequest(url){
        throw new NotImplementedException(&apos;SimbaBase.sendTransactionRequest Not Implemented&apos;);
    }

    /**
     * @abstract
     * (Abstract) Call a method on the API with files
     * @param {string} method - the method to call
     * @param {Object} parameters - the parameters for the method
     * @param {Array&lt;Blob|File&gt;} files - the files
     * @return {Promise&lt;Object&gt;} - a promise resolving with the transaction details
     */
    callMethodWithFile(method, parameters, files) {
        throw new NotImplementedException(&apos;SimbaBase.callMethod Not Implemented&apos;);
    }

    /**
     * @abstract
     * (Abstract) Get the status of a transaction by ID
     * @param {string} txnId - the transaction ID
     * @return {Promise&lt;Object&gt;} - a promise resolving with the transaction details
     */
    getTransactionStatus(txnId){
        throw new NotImplementedException(&apos;SimbaBase.getTransactionStatus Not Implemented&apos;);
    }

    /**
     * @abstract
     * @private
     * (Abstract) Gets the status of a transaction
     * @param {Object} txn - a transaction object
     * @return {Object} - an object with status details
     */
    checkTransactionStatusFromObject(txn){
        throw new NotImplementedException(&apos;SimbaBase.checkTransactionStatusFromObject Not Implemented&apos;);
    }

    /**
     * @abstract
     * @private
     * (Abstract) Check if the transaction is complete
     * @param {Object} txn - the transaction object
     * @return {boolean} - is the transaction complete
     */
    checkTransactionDone(txn){
        throw new NotImplementedException(&apos;SimbaBase.checkTransactionDone Not Implemented&apos;);
    }

    /**
     * @abstract
     * (Abstract) Gets the status of a transaction by ID
     * @param {string} txnId - a transaction ID
     * @return {Object} - an object with status details
     */
    checkTransactionStatus(txnId){
        throw new NotImplementedException(&apos;SimbaBase.checkTransactionStatus Not Implemented&apos;);
    }

    /**
     * @abstract
     * (Abstract) Get the balance for the attached Wallet
     * @return {Promise&lt;Object&gt;} - the balance
     */
    getBalance(){
        throw new NotImplementedException(&apos;SimbaBase.getBalance Not Implemented&apos;);
    }

    /**
     * @abstract
     * (Abstract) Add funds to the attached Wallet.
     * Please check the output of this method. It is of the form
     * ```
     * {
     *     txnId: null,
     *     faucet_url: null,
     *     poa: true
     * }
     * ```
     *
     * If successful, txnId will be populated.
     * If the network is PoA, then poa will be true, and txnId will be null
     * If the faucet for the network is external (e.g. Rinkeby, Ropsten, etc), then txnId will be null,
     * and faucet_url will be populated with a URL. You should present this URL to your users to direct them
     * to request funds there.
     * @return {Promise&lt;Object&gt;} - details of the txn
     */
    addFunds(){
        throw new NotImplementedException(&apos;SimbaBase.addFunds Not Implemented&apos;);
    }

    /**
     * Returns an object with &apos;future&apos; and &apos;cancel&apos; keys.
     * future is the promise to listen on for the response or an error.
     * cancel is a function - call it to cancel the polling.
     * @param {string} txnId - the transaction ID
     * @param {number} [pollInterval=5000] - the interval in ms for polling
     */
    waitForSuccessOrError(txnId, pollInterval){
        if(!pollInterval) pollInterval = 5000;

        return pollWrapper({
            request: () =&gt; this.getTransactionStatus(txnId),
            pollingPeriod: pollInterval, // ms
            shouldStop: (txn)=&gt; this.checkTransactionDone(this.checkTransactionStatusFromObject(txn))
        });
    }

    /**
     * Set the wallet
     * @param {Wallet} wallet - the wallet
     */
    setWallet(wallet){
        this.wallet = wallet;
    }

    /**
     * Set the API Key to authenticate calls
     * @param {string} apiKey - the API Key
     */
    setApiKey(apiKey){
        this.apiKey = apiKey;
    }

    /**
     * Set the API Key to authenticate management calls
     * @param {string} managementKey - the management API Key
     */
    setManagementKey(managementKey){
        this.managementKey = managementKey;
    }

    /**
     * @private
     * Get API Call auth headers
     * @returns {{APIKEY: *, &quot;Content-Type&quot;: string}}
     */
    apiAuthHeaders() {
        return {
            APIKEY: this.apiKey,
        }
    }

    /**
     * @private
     * Get management API Call auth headers
     * @returns {{APIKEY: *, &quot;Content-Type&quot;: string}}
     */
    managementAuthHeaders() {
        return {
            APIKEY: this.managementKey,
        }
    }

    /**
     * @private
     * Validate the method call against the app metadata
     * @param {string} methodName - the methods name
     * @param {Object} parameters - the parameters for the method call
     * @param {Array} [files] - Optional array of files
     * @returns {boolean}
     * @throws {MissingMetadataException} - App Metadata not yet retrieved
     * @throws {BadMetadataException} - App Metadata doesn&apos;t have methods
     * @throws {MethodCallValidationMetadataException} - Method call fails validation
     */
    validateCall(methodName, parameters, files){
        if (!this.metadata) {
            throw new MissingMetadataException(&quot;App Metadata not yet retrieved&quot;);
        }

        if (!this.metadata.methods) {
            throw new BadMetadataException(&quot;App Metadata doesn&apos;t have methods!&quot;);
        }

        if(!(methodName in this.metadata.methods)){
            throw new MethodCallValidationMetadataException(`Method &quot;${methodName}&quot; not found`);
        }

        let methodMeta = this.metadata.methods[methodName];

        if(files &amp;&amp; !(&apos;_files&apos; in methodMeta.parameters)){
            throw new MethodCallValidationMetadataException(`Method &quot;${methodName}&quot; does not accept files`);
        }

        if(parameters[&apos;_files&apos;]){
            throw new MethodCallValidationMetadataException(`Files must not be passed in through the parameters argument`);
        }

        if(files){
            for(let i = 0; i &lt; files.length; i++){
                if(!(files[i] instanceof Blob) || !(files[i] instanceof File)){
                    throw new MethodCallValidationMetadataException(`Item at position ${i} of &quot;files&quot; is not a Blob or a File`);
                }
            }
        }

        let paramNames = Object.keys(parameters);

        paramNames.forEach((key)=&gt;{
            if(!(key in methodMeta.parameters)){
                throw new MethodCallValidationMetadataException(`Parameter &quot;${key}&quot; is not valid for method &quot;${methodName}&quot;`);
            }
            //TODO: Type checks
        });

        //We expect _files to be missing, as it&apos;s passed separately
        let missing = Object.keys(methodMeta.parameters).filter((key)=&gt;paramNames.indexOf(key) &lt; 0 &amp;&amp; key !== &apos;_files&apos;);

        if(missing.length){
            throw new MethodCallValidationMetadataException(`Parameters [${missing.join(&apos;,&apos;)}] not present for method &quot;${methodName}&quot;`);
        }

        return true;
    }

    /**
     * @private
     * Validate the transaction list call against the app metadata
     * @param {string} methodName - the methods name
     * @param {Object} parameters - the parameters for the query
     * @returns {boolean}
     * @throws {MissingMetadataException} - App Metadata not yet retrieved
     * @throws {BadMetadataException} - App Metadata doesn&apos;t have methods
     * @throws {MethodCallValidationMetadataException} - Method call fails validation
     */
    validateGetCall(methodName, parameters){
        if (!this.metadata) {
            throw new MissingMetadataException(&quot;App Metadata not yet retrieved&quot;);
        }

        if (!this.metadata.methods) {
            throw new BadMetadataException(&quot;App Metadata doesn&apos;t have methods!&quot;);
        }

        if(!(methodName in this.metadata.methods)){
            throw new MethodCallValidationMetadataException(`Method &quot;${methodName}&quot; not found`);
        }

        return true;
    }

    /**
     * @private
     * Validate the transaction list call against the app metadata
     * @returns {boolean}
     * @throws {MissingMetadataException} - App Metadata not yet retrieved
     * @throws {BadMetadataException} - App Metadata doesn&apos;t have methods
     */
    validateAnyGetCall(){
        if (!this.metadata) {
            throw new MissingMetadataException(&quot;App Metadata not yet retrieved&quot;);
        }

        if (!this.metadata.methods) {
            throw new BadMetadataException(&quot;App Metadata doesn&apos;t have methods!&quot;);
        }

        return true;
    }
}
</code></pre>

</div>

<footer class="footer">
  Generated by <a href="https://esdoc.org">ESDoc<span data-ice="esdocVersion">(1.1.0)</span><img src="./image/esdoc-logo-mini-black.png"></a>
</footer>

<script src="script/search_index.js"></script>
<script src="script/search.js"></script>
<script src="script/pretty-print.js"></script>
<script src="script/inherited-summary.js"></script>
<script src="script/test-summary.js"></script>
<script src="script/inner-link.js"></script>
<script src="script/patch-for-local.js"></script>
</body>
</html>
